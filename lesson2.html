<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Day 2: Shapes & Materials - Exploring Geometries</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- Day 2 Info Panel -->
  <div class="info-panel">
    <h1>ğŸ¨ Day 2: Shapes & Materials</h1>
    <p><strong>Concept:</strong> Exploring Geometries & Material Types</p>
    <p><strong>Skills:</strong> Built-in Geometries Â· Material Properties Â· Lighting</p>
    <p><strong>Layout:</strong> Front (purple spheres) = Materials Â· Back (colorful) = Geometries</p>
    <div class="controls-info">
      <p><strong>ğŸ–±ï¸ Controls:</strong></p>
      <ul>
        <li>Left click + drag to rotate</li>
        <li>Right click + drag to pan</li>
        <li>Scroll to zoom</li>
      </ul>
    </div>
  </div>

  <!-- ThreeJS Core Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- OrbitControls for interactive camera -->
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

  <!-- Day 2 Script -->
  <script>
    // ========================================
    // DAY 2: SHAPES & MATERIALS
    // Learning: Built-in Geometries and Material Types
    // ========================================

    // SETUP: Scene, Camera, Renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f0f1e);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 3, 8);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // ORBIT CONTROLS - Interactive camera movement
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Smooth camera movement
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 20;

    // ========================================
    // LIGHTING SETUP
    // Materials like MeshStandardMaterial need lights to be visible!
    // ========================================

    // Ambient Light - provides base illumination to all objects
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // Directional Light - simulates sunlight
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7.5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    // Point Light - colored accent light
    const pointLight = new THREE.PointLight(0xff6b6b, 0.5, 100);
    pointLight.position.set(-5, 5, -5);
    scene.add(pointLight);

    // ========================================
    // GEOMETRY GALLERY - All Built-in Shapes!
    // ========================================

    const shapes = [];
    const spacing = 2.5; // Distance between shapes
    let xPos = -7.5; // Starting X position
    const yPos = 0;

    // SHAPE 1: BOX GEOMETRY (Cube)
    const boxGeo = new THREE.BoxGeometry(1, 1, 1);
    const boxMat = new THREE.MeshStandardMaterial({
      color: 0x00ff88,
      metalness: 0.3,
      roughness: 0.4
    });
    const box = new THREE.Mesh(boxGeo, boxMat);
    box.position.set(xPos, yPos, 0);
    box.castShadow = true;
    box.receiveShadow = true;
    scene.add(box);
    shapes.push({ mesh: box, name: 'Box' });
    xPos += spacing;

    // SHAPE 2: SPHERE GEOMETRY
    const sphereGeo = new THREE.SphereGeometry(0.6, 32, 32);
    const sphereMat = new THREE.MeshStandardMaterial({
      color: 0xff6b6b,
      metalness: 0.7,
      roughness: 0.2
    });
    const sphere = new THREE.Mesh(sphereGeo, sphereMat);
    sphere.position.set(xPos, yPos, 0);
    sphere.castShadow = true;
    sphere.receiveShadow = true;
    scene.add(sphere);
    shapes.push({ mesh: sphere, name: 'Sphere' });
    xPos += spacing;

    // SHAPE 3: CONE GEOMETRY
    const coneGeo = new THREE.ConeGeometry(0.6, 1.2, 32);
    const coneMat = new THREE.MeshStandardMaterial({
      color: 0xffd93d,
      metalness: 0.1,
      roughness: 0.6
    });
    const cone = new THREE.Mesh(coneGeo, coneMat);
    cone.position.set(xPos, yPos, 0);
    cone.castShadow = true;
    cone.receiveShadow = true;
    scene.add(cone);
    shapes.push({ mesh: cone, name: 'Cone' });
    xPos += spacing;

    // SHAPE 4: CYLINDER GEOMETRY
    const cylinderGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.2, 32);
    const cylinderMat = new THREE.MeshStandardMaterial({
      color: 0x6bcf7f,
      metalness: 0.5,
      roughness: 0.3
    });
    const cylinder = new THREE.Mesh(cylinderGeo, cylinderMat);
    cylinder.position.set(xPos, yPos, 0);
    cylinder.castShadow = true;
    cylinder.receiveShadow = true;
    scene.add(cylinder);
    shapes.push({ mesh: cylinder, name: 'Cylinder' });
    xPos += spacing;

    // SHAPE 5: TORUS GEOMETRY (Donut)
    const torusGeo = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
    const torusMat = new THREE.MeshStandardMaterial({
      color: 0x4ecdc4,
      metalness: 0.8,
      roughness: 0.1
    });
    const torus = new THREE.Mesh(torusGeo, torusMat);
    torus.position.set(xPos, yPos, 0);
    torus.castShadow = true;
    torus.receiveShadow = true;
    scene.add(torus);
    shapes.push({ mesh: torus, name: 'Torus' });
    xPos += spacing;

    // SHAPE 6: TORUS KNOT GEOMETRY
    const torusKnotGeo = new THREE.TorusKnotGeometry(0.5, 0.15, 100, 16);
    const torusKnotMat = new THREE.MeshStandardMaterial({
      color: 0xb794f6,
      metalness: 0.6,
      roughness: 0.2
    });
    const torusKnot = new THREE.Mesh(torusKnotGeo, torusKnotMat);
    torusKnot.position.set(xPos, yPos, 0);
    torusKnot.castShadow = true;
    torusKnot.receiveShadow = true;
    scene.add(torusKnot);
    shapes.push({ mesh: torusKnot, name: 'TorusKnot' });

    // ========================================
    // MATERIAL COMPARISON - Front Row
    // Same shape (sphere), different materials
    // Positioned closer to camera (z=3) to be clearly visible
    // ========================================

    const matShapes = [];
    let matXPos = -5;
    const matYPos = 0; // Same height as main shapes
    const matZPos = 3; // Closer to camera

    // MeshBasicMaterial - No lighting needed, always visible
    const basicGeo = new THREE.SphereGeometry(0.5, 32, 32);
    const basicMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
    const basicSphere = new THREE.Mesh(basicGeo, basicMat);
    basicSphere.position.set(matXPos, matYPos, matZPos);
    scene.add(basicSphere);
    matShapes.push({ mesh: basicSphere, name: 'Basic' });
    matXPos += 2.5;

    // MeshLambertMaterial - Matte, non-shiny surface
    const lambertGeo = new THREE.SphereGeometry(0.5, 32, 32);
    const lambertMat = new THREE.MeshLambertMaterial({ color: 0xff00ff });
    const lambertSphere = new THREE.Mesh(lambertGeo, lambertMat);
    lambertSphere.position.set(matXPos, matYPos, matZPos);
    lambertSphere.castShadow = true;
    lambertSphere.receiveShadow = true;
    scene.add(lambertSphere);
    matShapes.push({ mesh: lambertSphere, name: 'Lambert' });
    matXPos += 2.5;

    // MeshPhongMaterial - Shiny surface with specular highlights
    const phongGeo = new THREE.SphereGeometry(0.5, 32, 32);
    const phongMat = new THREE.MeshPhongMaterial({
      color: 0xff00ff,
      shininess: 100
    });
    const phongSphere = new THREE.Mesh(phongGeo, phongMat);
    phongSphere.position.set(matXPos, matYPos, matZPos);
    phongSphere.castShadow = true;
    phongSphere.receiveShadow = true;
    scene.add(phongSphere);
    matShapes.push({ mesh: phongSphere, name: 'Phong' });
    matXPos += 2.5;

    // MeshStandardMaterial - Physically-based rendering (PBR)
    const standardGeo = new THREE.SphereGeometry(0.5, 32, 32);
    const standardMat = new THREE.MeshStandardMaterial({
      color: 0xff00ff,
      metalness: 0.7,
      roughness: 0.2
    });
    const standardSphere = new THREE.Mesh(standardGeo, standardMat);
    standardSphere.position.set(matXPos, matYPos, matZPos);
    standardSphere.castShadow = true;
    standardSphere.receiveShadow = true;
    scene.add(standardSphere);
    matShapes.push({ mesh: standardSphere, name: 'Standard' });

    // ========================================
    // GROUND PLANE - To receive shadows
    // ========================================

    const planeGeo = new THREE.PlaneGeometry(25, 10);
    const planeMat = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      metalness: 0.0,
      roughness: 0.8
    });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -1.5;
    plane.receiveShadow = true;
    scene.add(plane);

    // ========================================
    // WIREFRAME EXAMPLE - Third Row
    // ========================================

    const wireGeo = new THREE.IcosahedronGeometry(0.7, 0);
    const wireMat = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      wireframe: true
    });
    const wireframe = new THREE.Mesh(wireGeo, wireMat);
    wireframe.position.set(0, 2.5, 0);
    scene.add(wireframe);

    // ========================================
    // ANIMATION LOOP
    // ========================================

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const elapsedTime = clock.getElapsedTime();

      // Rotate all geometry shapes
      shapes.forEach((shape, index) => {
        shape.mesh.rotation.x = elapsedTime * 0.3;
        shape.mesh.rotation.y = elapsedTime * 0.5;

        // Add a floating animation
        shape.mesh.position.y = Math.sin(elapsedTime + index) * 0.2;
      });

      // Rotate material comparison spheres
      matShapes.forEach((shape, index) => {
        shape.mesh.rotation.y = elapsedTime * 0.5;
      });

      // Rotate wireframe
      wireframe.rotation.x = elapsedTime * 0.4;
      wireframe.rotation.y = elapsedTime * 0.6;

      // Animate point light in a circle
      pointLight.position.x = Math.cos(elapsedTime * 0.5) * 8;
      pointLight.position.z = Math.sin(elapsedTime * 0.5) * 8;

      // Update controls
      controls.update();

      // Render
      renderer.render(scene, camera);
    }

    animate();

    // ========================================
    // WINDOW RESIZE HANDLER
    // ========================================

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    // ========================================
    // CONSOLE LEARNING TIPS
    // ========================================

    console.log('ğŸ¨ Day 2: Shapes & Materials Gallery!');
    console.log('');
    console.log('ğŸ“¦ BACK ROW - Geometry Types:');
    shapes.forEach(shape => {
      console.log(`  âœ“ ${shape.name}Geometry`);
    });
    console.log('');
    console.log('ğŸ­ FRONT ROW (Purple Spheres) - Material Types Comparison:');
    matShapes.forEach(mat => {
      console.log(`  âœ“ Mesh${mat.name}Material`);
    });
    console.log('');
    console.log('ğŸ“š What you learned:');
    console.log('  âœ“ BoxGeometry, SphereGeometry, ConeGeometry, etc.');
    console.log('  âœ“ MeshBasicMaterial (no lights needed)');
    console.log('  âœ“ MeshLambertMaterial (matte surface)');
    console.log('  âœ“ MeshPhongMaterial (shiny surface)');
    console.log('  âœ“ MeshStandardMaterial (PBR - most realistic)');
    console.log('  âœ“ Material properties: metalness, roughness, color');
    console.log('  âœ“ Wireframe mode for seeing geometry structure');
    console.log('  âœ“ Shadow casting and receiving');
    console.log('  âœ“ OrbitControls for camera interaction');
    console.log('');
    console.log('ğŸ”¬ Experiment Ideas:');
    console.log('  1. Change metalness values (0.0 to 1.0)');
    console.log('  2. Change roughness values (0.0 to 1.0)');
    console.log('  3. Try wireframe: true on different materials');
    console.log('  4. Adjust geometry parameters (radius, segments, etc.)');
    console.log('  5. Add your own custom shapes!');
  </script>
</body>

</html>