<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Day 5: Textures & Advanced Materials</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- Day 5 Info Panel -->
  <div class="info-panel">
    <h1>üñºÔ∏è Day 5: Textures & Materials</h1>
    <p><strong>Concept:</strong> Surface Details & Realistic Materials</p>
    <p><strong>Skills:</strong> Texture Maps ¬∑ UV Mapping ¬∑ PBR Workflow</p>
    <div class="texture-info">
      <p><strong>üìä Active Texture Maps:</strong></p>
      <ul>
        <li>‚úì Color/Albedo - Base surface color</li>
        <li>‚úì Normal Map - Surface detail illusion</li>
        <li>‚úì Roughness Map - Surface smoothness variation</li>
        <li>‚úì Metalness Map - Metallic areas</li>
        <li>‚úì AO (Ambient Occlusion) - Crevice darkening</li>
      </ul>
    </div>
    <div class="controls-info">
      <p><strong>‚å®Ô∏è Keyboard Controls:</strong></p>
      <ul>
        <li><kbd>1</kbd> - Show Color Map only</li>
        <li><kbd>2</kbd> - Show Normal Map effect</li>
        <li><kbd>3</kbd> - Show Roughness variation</li>
        <li><kbd>4</kbd> - All maps (PBR)</li>
        <li><kbd>5</kbd> - Wireframe UV view</li>
        <li><kbd>R</kbd> - Reset view</li>
      </ul>
      <p><strong>üñ±Ô∏è Mouse:</strong> Drag to rotate ¬∑ Scroll to zoom</p>
    </div>
  </div>

  <!-- ThreeJS Core Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- OrbitControls -->
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

  <!-- Day 5 Script -->
  <script>
    // ========================================
    // DAY 5: TEXTURES & ADVANCED MATERIALS
    // Learning: Texture Loading, UV Mapping, PBR Workflow
    // ========================================

    console.log('üñºÔ∏è Day 5: Textures & Advanced Materials');
    console.log('Creating procedural textures...');

    // SCENE SETUP
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // CAMERA
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 2, 5);

    // RENDERER
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // ORBIT CONTROLS
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 3;
    controls.maxDistance = 15;

    // ========================================
    // PROCEDURAL TEXTURE GENERATION
    // Creating textures without external images
    // ========================================

    function createColorTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');

      // Create brick-like pattern
      const brickWidth = 128;
      const brickHeight = 64;
      const mortarSize = 8;

      for (let y = 0; y < canvas.height; y += brickHeight) {
        for (let x = 0; x < canvas.width; x += brickWidth) {
          // Offset every other row
          const offsetX = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;

          // Brick color with variation
          const variation = Math.random() * 20 - 10;
          ctx.fillStyle = `rgb(${180 + variation}, ${80 + variation}, ${60 + variation})`;
          ctx.fillRect(
            (x + offsetX) % canvas.width,
            y,
            brickWidth - mortarSize,
            brickHeight - mortarSize
          );
        }
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(2, 2);
      return texture;
    }

    function createNormalMap() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');

      // Base normal color (pointing straight out = RGB(128, 128, 255))
      ctx.fillStyle = 'rgb(128, 128, 255)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Add bump details
      const brickWidth = 128;
      const brickHeight = 64;

      for (let y = 0; y < canvas.height; y += brickHeight) {
        for (let x = 0; x < canvas.width; x += brickWidth) {
          const offsetX = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;

          // Create gradient for brick edges (simulates depth)
          const gradient = ctx.createLinearGradient(
            (x + offsetX) % canvas.width,
            y,
            (x + offsetX) % canvas.width + brickWidth - 8,
            y + brickHeight - 8
          );
          gradient.addColorStop(0, 'rgb(100, 100, 255)');
          gradient.addColorStop(0.5, 'rgb(128, 128, 255)');
          gradient.addColorStop(1, 'rgb(150, 150, 255)');

          ctx.fillStyle = gradient;
          ctx.fillRect(
            (x + offsetX) % canvas.width,
            y,
            brickWidth - 8,
            brickHeight - 8
          );
        }
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(2, 2);
      return texture;
    }

    function createRoughnessMap() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');

      // Variable roughness - mortar is rougher (lighter), bricks vary
      ctx.fillStyle = 'rgb(200, 200, 200)'; // Mortar - rough
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const brickWidth = 128;
      const brickHeight = 64;

      for (let y = 0; y < canvas.height; y += brickHeight) {
        for (let x = 0; x < canvas.width; x += brickWidth) {
          const offsetX = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;

          // Bricks - smoother (darker)
          const roughness = Math.random() * 50 + 100; // 100-150
          ctx.fillStyle = `rgb(${roughness}, ${roughness}, ${roughness})`;
          ctx.fillRect(
            (x + offsetX) % canvas.width,
            y,
            brickWidth - 8,
            brickHeight - 8
          );
        }
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(2, 2);
      return texture;
    }

    function createMetalnessMap() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');

      // Non-metallic base (bricks)
      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Add some metallic specks randomly
      for (let i = 0; i < 100; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 10 + 5;
        ctx.fillStyle = 'rgb(255, 255, 255)';
        ctx.fillRect(x, y, size, size);
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(2, 2);
      return texture;
    }

    function createAOMap() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');

      // Base - fully lit
      ctx.fillStyle = 'rgb(255, 255, 255)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Darken mortar gaps (ambient occlusion)
      ctx.fillStyle = 'rgb(100, 100, 100)';
      const brickWidth = 128;
      const brickHeight = 64;

      for (let y = 0; y < canvas.height; y += brickHeight) {
        for (let x = 0; x < canvas.width; x += brickWidth) {
          const offsetX = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;

          // Draw dark lines for gaps (vertical mortar line)
          const vertLineX = (x + offsetX + brickWidth - 8) % canvas.width;
          ctx.fillRect(vertLineX, y, 8, brickHeight);
          
          // Draw dark lines for gaps (horizontal mortar line)
          const horizLineX = (x + offsetX) % canvas.width;
          const horizLineY = y + brickHeight - 8;
          if (horizLineY < canvas.height) {
            ctx.fillRect(horizLineX, horizLineY, Math.min(brickWidth, canvas.width - horizLineX), 8);
          }
        }
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(2, 2);
      return texture;
    }

    function createCheckerTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');

      const tileSize = 64;
      for (let y = 0; y < canvas.height; y += tileSize) {
        for (let x = 0; x < canvas.width; x += tileSize) {
          const isEven = ((x / tileSize) + (y / tileSize)) % 2 === 0;
          ctx.fillStyle = isEven ? '#ffffff' : '#cccccc';
          ctx.fillRect(x, y, tileSize, tileSize);
        }
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      return texture;
    }

    // Create all texture maps
    const colorMap = createColorTexture();
    const normalMap = createNormalMap();
    const roughnessMap = createRoughnessMap();
    const metalnessMap = createMetalnessMap();
    const aoMap = createAOMap();
    const checkerMap = createCheckerTexture();

    console.log('‚úì Textures created successfully');

    // ========================================
    // LIGHTING
    // ========================================

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    // Point lights for better material visibility
    const pointLight1 = new THREE.PointLight(0x4488ff, 0.5, 20);
    pointLight1.position.set(-5, 3, 5);
    scene.add(pointLight1);

    const pointLight2 = new THREE.PointLight(0xff8844, 0.5, 20);
    pointLight2.position.set(5, 3, -5);
    scene.add(pointLight2);

    // ========================================
    // CREATE DEMO OBJECTS
    // ========================================

    // Main demonstration sphere with all texture maps
    const sphereGeometry = new THREE.SphereGeometry(1.5, 64, 64);
    const sphereMaterial = new THREE.MeshStandardMaterial({
      map: colorMap,
      normalMap: normalMap,
      normalScale: new THREE.Vector2(0.5, 0.5),
      roughnessMap: roughnessMap,
      roughness: 0.8,
      metalnessMap: metalnessMap,
      metalness: 0.2,
      aoMap: aoMap,
      aoMapIntensity: 1.0
    });

    // Need to set second UV channel for AO map
    sphereGeometry.setAttribute('uv2', sphereGeometry.attributes.uv);

    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.set(0, 1.5, 0);
    sphere.castShadow = true;
    sphere.receiveShadow = true;
    scene.add(sphere);

    // Comparison cubes showing individual maps
    const cubeSize = 0.8;
    const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

    // Cube 1: Color map only
    const cube1Material = new THREE.MeshStandardMaterial({
      map: colorMap,
      roughness: 0.8,
      metalness: 0
    });
    const cube1 = new THREE.Mesh(cubeGeometry, cube1Material);
    cube1.position.set(-3, 0.5, 2);
    cube1.castShadow = true;
    scene.add(cube1);

    // Cube 2: Normal map only
    const cube2Material = new THREE.MeshStandardMaterial({
      color: 0xcccccc,
      normalMap: normalMap,
      normalScale: new THREE.Vector2(1, 1),
      roughness: 0.5,
      metalness: 0
    });
    const cube2 = new THREE.Mesh(cubeGeometry, cube2Material);
    cube2.position.set(-1, 0.5, 2);
    cube2.castShadow = true;
    scene.add(cube2);

    // Cube 3: Roughness variation
    const cube3Material = new THREE.MeshStandardMaterial({
      color: 0x888888,
      roughnessMap: roughnessMap,
      roughness: 1.0,
      metalness: 0
    });
    const cube3 = new THREE.Mesh(cubeGeometry, cube3Material);
    cube3.position.set(1, 0.5, 2);
    cube3.castShadow = true;
    scene.add(cube3);

    // Cube 4: Metalness variation
    const cube4Material = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalnessMap: metalnessMap,
      metalness: 1.0,
      roughness: 0.2
    });
    const cube4 = new THREE.Mesh(cubeGeometry, cube4Material);
    cube4.position.set(3, 0.5, 2);
    cube4.castShadow = true;
    scene.add(cube4);

    // Ground plane with checker texture
    const planeGeometry = new THREE.PlaneGeometry(20, 20);
    const planeMaterial = new THREE.MeshStandardMaterial({
      map: checkerMap,
      roughness: 0.8,
      metalness: 0
    });
    checkerMap.repeat.set(10, 10);

    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // ========================================
    // DISPLAY MODES
    // ========================================

    let displayMode = 'all';

    function setDisplayMode(mode) {
      displayMode = mode;

      switch (mode) {
        case 'color':
          sphereMaterial.map = colorMap;
          sphereMaterial.normalMap = null;
          sphereMaterial.roughnessMap = null;
          sphereMaterial.metalnessMap = null;
          sphereMaterial.aoMap = null;
          sphereMaterial.roughness = 0.8;
          sphereMaterial.metalness = 0;
          sphereMaterial.wireframe = false;
          console.log('üì∑ Mode: Color Map Only');
          break;

        case 'normal':
          sphereMaterial.map = null;
          sphereMaterial.color.setHex(0xcccccc);
          sphereMaterial.normalMap = normalMap;
          sphereMaterial.normalScale.set(2, 2);
          sphereMaterial.roughnessMap = null;
          sphereMaterial.metalnessMap = null;
          sphereMaterial.aoMap = null;
          sphereMaterial.roughness = 0.5;
          sphereMaterial.metalness = 0;
          sphereMaterial.wireframe = false;
          console.log('üì∑ Mode: Normal Map Effect');
          break;

        case 'roughness':
          sphereMaterial.map = null;
          sphereMaterial.color.setHex(0x888888);
          sphereMaterial.normalMap = null;
          sphereMaterial.roughnessMap = roughnessMap;
          sphereMaterial.metalnessMap = null;
          sphereMaterial.aoMap = null;
          sphereMaterial.roughness = 1.0;
          sphereMaterial.metalness = 0;
          sphereMaterial.wireframe = false;
          console.log('üì∑ Mode: Roughness Variation');
          break;

        case 'all':
          sphereMaterial.map = colorMap;
          sphereMaterial.normalMap = normalMap;
          sphereMaterial.normalScale.set(0.5, 0.5);
          sphereMaterial.roughnessMap = roughnessMap;
          sphereMaterial.metalnessMap = metalnessMap;
          sphereMaterial.aoMap = aoMap;
          sphereMaterial.roughness = 0.8;
          sphereMaterial.metalness = 0.2;
          sphereMaterial.wireframe = false;
          console.log('üì∑ Mode: All Maps (Full PBR)');
          break;

        case 'wireframe':
          sphereMaterial.wireframe = true;
          console.log('üì∑ Mode: Wireframe UV View');
          break;
      }

      sphereMaterial.needsUpdate = true;
    }

    // ========================================
    // KEYBOARD CONTROLS
    // ========================================

    window.addEventListener('keydown', (event) => {
      switch (event.key) {
        case '1':
          setDisplayMode('color');
          break;
        case '2':
          setDisplayMode('normal');
          break;
        case '3':
          setDisplayMode('roughness');
          break;
        case '4':
          setDisplayMode('all');
          break;
        case '5':
          setDisplayMode('wireframe');
          break;
        case 'r':
        case 'R':
          camera.position.set(0, 2, 5);
          controls.target.set(0, 1, 0);
          setDisplayMode('all');
          console.log('üîÑ View reset');
          break;
      }
    });

    // ========================================
    // ANIMATION LOOP
    // ========================================

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const elapsedTime = clock.getElapsedTime();

      // Rotate main sphere slowly
      sphere.rotation.y = elapsedTime * 0.2;

      // Rotate comparison cubes
      cube1.rotation.y = elapsedTime * 0.5;
      cube2.rotation.y = elapsedTime * 0.5;
      cube3.rotation.y = elapsedTime * 0.5;
      cube4.rotation.y = elapsedTime * 0.5;

      // Animate point lights
      pointLight1.position.x = Math.cos(elapsedTime * 0.5) * 8;
      pointLight1.position.z = Math.sin(elapsedTime * 0.5) * 8;

      pointLight2.position.x = Math.cos(elapsedTime * 0.5 + Math.PI) * 8;
      pointLight2.position.z = Math.sin(elapsedTime * 0.5 + Math.PI) * 8;

      // Update controls
      controls.update();

      // Render
      renderer.render(scene, camera);
    }

    animate();

    // ========================================
    // WINDOW RESIZE
    // ========================================

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    // ========================================
    // CONSOLE INFO
    // ========================================

    console.log('');
    console.log('üìö What you\'re learning:');
    console.log('  ‚úì Texture creation and loading');
    console.log('  ‚úì Color/Albedo maps - Base color');
    console.log('  ‚úì Normal maps - Surface detail illusion');
    console.log('  ‚úì Roughness maps - Surface smoothness variation');
    console.log('  ‚úì Metalness maps - Metallic area definition');
    console.log('  ‚úì AO maps - Ambient occlusion for depth');
    console.log('  ‚úì UV mapping - How textures wrap around geometry');
    console.log('  ‚úì Texture repeat and wrapping modes');
    console.log('  ‚úì PBR (Physically-Based Rendering) workflow');
    console.log('');
    console.log('üéÆ Try these:');
    console.log('  1-5: Switch between different texture display modes');
    console.log('  R: Reset view');
    console.log('  Mouse: Orbit around to see texture details');
    console.log('');
    console.log('üí° Notice:');
    console.log('  - How normal maps add surface detail without geometry');
    console.log('  - How roughness creates different surface properties');
    console.log('  - How multiple maps combine for realistic materials');
  </script>
</body>

</html>