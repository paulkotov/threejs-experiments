<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Day 7: Custom Geometry & Shader Basics</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- Day 7 Info Panel -->
  <div class="info-panel">
    <h1>ğŸ”ï¸ Day 7: Custom Geometry & Shaders</h1>
    <p><strong>Concept:</strong> BufferGeometry & GLSL Shader Programming</p>
    <p><strong>Skills:</strong> Vertices Â· Attributes Â· Shaders Â· Uniforms</p>
    <div class="shader-info">
      <p><strong>ğŸ¨ Shader Features:</strong></p>
      <ul>
        <li>âœ“ Custom vertex positions (100Ã—100 grid)</li>
        <li>âœ“ Animated wave displacement</li>
        <li>âœ“ Height-based coloring</li>
        <li>âœ“ Custom lighting in fragment shader</li>
        <li>âœ“ Time-based animation uniforms</li>
      </ul>
    </div>
    <div class="controls-info">
      <p><strong>âŒ¨ï¸ Keyboard Controls:</strong></p>
      <ul>
        <li><kbd>Space</kbd> - Pause/Resume waves</li>
        <li><kbd>W</kbd> - Toggle wireframe</li>
        <li><kbd>+</kbd> / <kbd>-</kbd> - Wave speed</li>
        <li><kbd>â†‘</kbd> / <kbd>â†“</kbd> - Wave height</li>
        <li><kbd>R</kbd> - Reset settings</li>
      </ul>
      <p><strong>ğŸ–±ï¸ Mouse:</strong> Drag to rotate Â· Scroll to zoom</p>
      <p><strong>âš¡ Wave Speed:</strong> <span id="wave-speed">1.0x</span></p>
      <p><strong>ğŸ“Š Wave Height:</strong> <span id="wave-height">1.0x</span></p>
    </div>
  </div>

  <!-- ThreeJS Core Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- OrbitControls -->
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

  <!-- Day 7 Script -->
  <script>
    // ========================================
    // DAY 7: CUSTOM GEOMETRY & SHADERS
    // Learning: BufferGeometry, GLSL, Vertex/Fragment Shaders
    // ========================================

    console.log('ğŸ”ï¸ Day 7: Custom Geometry & Shader Basics');
    console.log('Creating custom wave terrain...');

    // SCENE SETUP
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1e);
    scene.fog = new THREE.Fog(0x0a0a1e, 50, 200);

    // CAMERA
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 30, 50);

    // RENDERER
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // ORBIT CONTROLS
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 10;
    controls.maxDistance = 150;
    controls.maxPolarAngle = Math.PI / 2.1; // Prevent going below terrain

    // ========================================
    // CUSTOM BUFFER GEOMETRY
    // Creating a terrain grid from scratch
    // ========================================

    const gridSize = 100;  // 100x100 grid
    const gridSpacing = 1;
    const totalVertices = gridSize * gridSize;

    // Create empty BufferGeometry
    const geometry = new THREE.BufferGeometry();

    // Arrays to hold our vertex data
    const positions = [];  // x, y, z coordinates
    const indices = [];    // Triangle indices
    const uvs = [];       // UV coordinates for texturing
    const colors = [];    // Vertex colors

    // Generate vertices
    for (let z = 0; z < gridSize; z++) {
      for (let x = 0; x < gridSize; x++) {
        // Position
        const posX = (x - gridSize / 2) * gridSpacing;
        const posY = 0; // Will be animated by shader
        const posZ = (z - gridSize / 2) * gridSpacing;
        positions.push(posX, posY, posZ);

        // UV coordinates (0-1 range)
        const u = x / (gridSize - 1);
        const v = z / (gridSize - 1);
        uvs.push(u, v);

        // Initial vertex color (will be modified by shader)
        colors.push(1, 1, 1);
      }
    }

    // Generate indices (two triangles per quad)
    for (let z = 0; z < gridSize - 1; z++) {
      for (let x = 0; x < gridSize - 1; x++) {
        const topLeft = z * gridSize + x;
        const topRight = topLeft + 1;
        const bottomLeft = (z + 1) * gridSize + x;
        const bottomRight = bottomLeft + 1;

        // First triangle
        indices.push(topLeft, bottomLeft, topRight);
        // Second triangle
        indices.push(topRight, bottomLeft, bottomRight);
      }
    }

    // Set attributes on geometry
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setIndex(indices);

    // Compute normals for lighting
    geometry.computeVertexNormals();

    console.log(`âœ“ Created custom geometry: ${totalVertices} vertices, ${indices.length / 3} triangles`);

    // ========================================
    // CUSTOM SHADER MATERIAL
    // Writing GLSL shaders from scratch!
    // ========================================

    // Vertex Shader - Runs for each vertex
    const vertexShader = `
      uniform float uTime;
      uniform float uWaveSpeed;
      uniform float uWaveHeight;
      
      varying vec3 vPosition;
      varying float vElevation;
      varying vec2 vUv;
      
      void main() {
        vec3 pos = position;
        
        // Create waves using sine functions
        float wave1 = sin(pos.x * 0.3 + uTime * uWaveSpeed) * uWaveHeight;
        float wave2 = sin(pos.z * 0.4 + uTime * uWaveSpeed * 0.7) * uWaveHeight;
        float wave3 = sin((pos.x + pos.z) * 0.2 + uTime * uWaveSpeed * 1.3) * uWaveHeight * 0.5;
        
        // Combine waves
        pos.y += wave1 + wave2 + wave3;
        
        // Pass data to fragment shader
        vPosition = pos;
        vElevation = pos.y;
        vUv = uv;
        
        // Final position
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    // Fragment Shader - Runs for each pixel
    const fragmentShader = `
      uniform float uTime;
      uniform float uWaveHeight;
      
      varying vec3 vPosition;
      varying float vElevation;
      varying vec2 vUv;
      
      void main() {
        // Color based on height
        vec3 deepColor = vec3(0.1, 0.05, 0.3);   // Dark purple (low)
        vec3 midColor = vec3(0.2, 0.5, 0.8);      // Blue (mid)
        vec3 peakColor = vec3(0.9, 0.9, 1.0);     // White (peak)
        
        // Dynamically normalize elevation based on current wave height
        // Wave range: -(uWaveHeight * 2.5) to +(uWaveHeight * 2.5)
        float maxElevation = uWaveHeight * 2.5;
        float normalizedHeight = (vElevation + maxElevation) / (maxElevation * 2.0);
        normalizedHeight = clamp(normalizedHeight, 0.0, 1.0);
        
        // Mix colors based on height
        vec3 color;
        if (normalizedHeight < 0.5) {
          color = mix(deepColor, midColor, normalizedHeight * 2.0);
        } else {
          color = mix(midColor, peakColor, (normalizedHeight - 0.5) * 2.0);
        }
        
        // Add subtle grid pattern
        float gridX = abs(fract(vUv.x * 50.0) - 0.5);
        float gridZ = abs(fract(vUv.y * 50.0) - 0.5);
        float grid = step(0.48, min(gridX, gridZ)) * 0.1;
        
        color += grid;
        
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // Create shader material
    const material = new THREE.ShaderMaterial({
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: {
        uTime: { value: 0.0 },
        uWaveSpeed: { value: 1.0 },
        uWaveHeight: { value: 3.0 }
      },
      wireframe: false,
      side: THREE.DoubleSide
    });

    // Create mesh
    const terrain = new THREE.Mesh(geometry, material);
    scene.add(terrain);

    // ========================================
    // LIGHTING (for reference spheres)
    // ========================================

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // Reference sphere (shows BufferGeometry basics)
    const sphereGeo = new THREE.SphereGeometry(3, 16, 16);
    const sphereMat = new THREE.MeshStandardMaterial({
      color: 0xff6b6b,
      wireframe: false,
      roughness: 0.5,
      metalness: 0.5
    });
    const sphere = new THREE.Mesh(sphereGeo, sphereMat);
    sphere.position.set(30, 10, 0);
    scene.add(sphere);

    // ========================================
    // ANIMATION VARIABLES
    // ========================================

    let isPaused = false;
    let waveSpeed = 1.0;
    let waveHeight = 1.0;
    const clock = new THREE.Clock();

    // ========================================
    // UI UPDATE FUNCTIONS
    // ========================================

    function updateUI() {
      document.getElementById('wave-speed').textContent = waveSpeed.toFixed(1) + 'x';
      document.getElementById('wave-height').textContent = waveHeight.toFixed(1) + 'x';
    }

    // ========================================
    // KEYBOARD CONTROLS
    // ========================================

    window.addEventListener('keydown', (event) => {
      switch (event.key) {
        case ' ':
          isPaused = !isPaused;
          console.log(isPaused ? 'â¸ï¸ Waves paused' : 'â–¶ï¸ Waves resumed');
          break;
        case 'w':
        case 'W':
          material.wireframe = !material.wireframe;
          sphereMat.wireframe = !sphereMat.wireframe;
          console.log(`ğŸ”² Wireframe: ${material.wireframe ? 'ON' : 'OFF'}`);
          break;
        case '+':
        case '=':
          waveSpeed = Math.min(waveSpeed + 0.2, 5);
          material.uniforms.uWaveSpeed.value = waveSpeed;
          updateUI();
          console.log(`â© Wave speed: ${waveSpeed.toFixed(1)}x`);
          break;
        case '-':
        case '_':
          waveSpeed = Math.max(waveSpeed - 0.2, 0.1);
          material.uniforms.uWaveSpeed.value = waveSpeed;
          updateUI();
          console.log(`âª Wave speed: ${waveSpeed.toFixed(1)}x`);
          break;
        case 'ArrowUp':
          waveHeight = Math.min(waveHeight + 0.2, 3);
          material.uniforms.uWaveHeight.value = waveHeight * 3.0;
          updateUI();
          console.log(`ğŸ“ˆ Wave height: ${waveHeight.toFixed(1)}x`);
          break;
        case 'ArrowDown':
          waveHeight = Math.max(waveHeight - 0.2, 0.2);
          material.uniforms.uWaveHeight.value = waveHeight * 3.0;
          updateUI();
          console.log(`ğŸ“‰ Wave height: ${waveHeight.toFixed(1)}x`);
          break;
        case 'r':
        case 'R':
          isPaused = false;
          waveSpeed = 1.0;
          waveHeight = 1.0;
          material.uniforms.uWaveHeight.value = 3.0;
          material.wireframe = false;
          sphereMat.wireframe = false;
          updateUI();
          console.log('ğŸ”„ Reset to defaults');
          break;
      }
    });

    // ========================================
    // ANIMATION LOOP
    // ========================================

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      if (!isPaused) {
        // Update shader uniform for time-based animation
        material.uniforms.uTime.value += delta * waveSpeed;
      }

      // Rotate reference sphere
      sphere.rotation.y += delta * 0.5;

      // Update controls
      controls.update();

      // Render
      renderer.render(scene, camera);
    }

    animate();

    // ========================================
    // WINDOW RESIZE
    // ========================================

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    // ========================================
    // CONSOLE INFO
    // ========================================

    console.log('');
    console.log('ğŸ“š What you\'re learning:');
    console.log('  âœ“ BufferGeometry - Custom geometry creation');
    console.log('  âœ“ Vertices - Individual points in 3D space');
    console.log('  âœ“ Indices - Define triangles from vertices');
    console.log('  âœ“ Attributes - Data per vertex (position, uv, color)');
    console.log('  âœ“ GLSL - OpenGL Shading Language');
    console.log('  âœ“ Vertex Shader - Processes each vertex');
    console.log('  âœ“ Fragment Shader - Processes each pixel');
    console.log('  âœ“ Uniforms - Variables passed from JavaScript');
    console.log('  âœ“ Varyings - Data passed vertex â†’ fragment');
    console.log('');
    console.log('ğŸ® Try these:');
    console.log('  W: Toggle wireframe to see the geometry structure');
    console.log('  +/-: Change wave animation speed');
    console.log('  â†‘â†“: Adjust wave amplitude');
    console.log('  Space: Pause and observe');
    console.log('');
    console.log('ğŸ’¡ Notice:');
    console.log('  - 100Ã—100 grid = 10,000 vertices!');
    console.log('  - Colors computed per-pixel in fragment shader');
    console.log('  - Waves calculated in vertex shader (GPU accelerated)');

    // Initial UI update
    updateUI();
  </script>
</body>

</html>