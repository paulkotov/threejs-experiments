<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Day 3: Camera & Controls - Mastering Perspective</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- Day 3 Info Panel -->
  <div class="info-panel">
    <h1>üì∏ Day 3: Camera & Controls</h1>
    <p><strong>Concept:</strong> Mastering Perspective & Camera Types</p>
    <p><strong>Skills:</strong> Camera Types ¬∑ FOV ¬∑ Positioning ¬∑ Advanced Controls</p>
    <div class="camera-info">
      <p><strong>üìπ Current Camera:</strong> <span id="camera-name">Perspective</span></p>
      <p><strong>üéØ FOV:</strong> <span id="fov-value">75¬∞</span></p>
      <p><strong>üìç Position:</strong> <span id="camera-position">0, 0, 0</span></p>
    </div>
    <div class="controls-info">
      <p><strong>‚å®Ô∏è Keyboard Controls:</strong></p>
      <ul>
        <li><kbd>1</kbd> - Perspective Camera (default)</li>
        <li><kbd>2</kbd> - Orthographic Camera (no perspective)</li>
        <li><kbd>3</kbd> - Wide FOV (100¬∞)</li>
        <li><kbd>4</kbd> - Normal FOV (75¬∞)</li>
        <li><kbd>5</kbd> - Narrow FOV (35¬∞)</li>
        <li><kbd>‚Üë‚Üì‚Üê‚Üí</kbd> - Move camera</li>
        <li><kbd>R</kbd> - Reset camera</li>
      </ul>
      <p><strong>üñ±Ô∏è Mouse:</strong></p>
      <ul>
        <li>Left drag - Rotate ¬∑ Right drag - Pan ¬∑ Scroll - Zoom</li>
      </ul>
    </div>
  </div>

  <!-- ThreeJS Core Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- OrbitControls -->
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

  <!-- Day 3 Script -->
  <script>
    // ========================================
    // DAY 3: CAMERA & CONTROLS
    // Learning: Camera Types, FOV, Positioning, Advanced Controls
    // ========================================

    // SCENE SETUP
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a15);
    scene.fog = new THREE.Fog(0x0a0a15, 10, 50); // Add depth with fog

    // RENDERER SETUP
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // ========================================
    // CAMERAS - Two Different Types
    // ========================================

    // PERSPECTIVE CAMERA - Natural perspective (objects farther = smaller)
    const perspectiveCamera = new THREE.PerspectiveCamera(
      75,                                     // Field of View
      window.innerWidth / window.innerHeight, // Aspect Ratio
      0.1,                                    // Near clipping plane
      1000                                    // Far clipping plane
    );
    perspectiveCamera.position.set(0, 5, 15);
    perspectiveCamera.lookAt(0, 0, 0);

    // ORTHOGRAPHIC CAMERA - No perspective (parallel projection)
    const frustumSize = 10;
    const aspect = window.innerWidth / window.innerHeight;
    const orthographicCamera = new THREE.OrthographicCamera(
      frustumSize * aspect / -2,  // left
      frustumSize * aspect / 2,   // right
      frustumSize / 2,            // top
      frustumSize / -2,           // bottom
      0.1,                        // near
      1000                        // far
    );
    orthographicCamera.position.set(0, 5, 15);
    orthographicCamera.lookAt(0, 0, 0);

    // ACTIVE CAMERA (starts with perspective)
    let camera = perspectiveCamera;
    let cameraType = 'perspective';

    // ========================================
    // ORBIT CONTROLS - Advanced Settings
    // ========================================

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 50;
    controls.maxPolarAngle = Math.PI / 2; // Prevent going below ground
    controls.enablePan = true;
    controls.panSpeed = 0.8;
    controls.rotateSpeed = 0.6;
    controls.zoomSpeed = 1.2;

    // ========================================
    // LIGHTING
    // ========================================

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 15, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.left = -20;
    directionalLight.shadow.camera.right = 20;
    directionalLight.shadow.camera.top = 20;
    directionalLight.shadow.camera.bottom = -20;
    scene.add(directionalLight);

    // Hemisphere light for nice ambient
    const hemisphereLight = new THREE.HemisphereLight(0x4488ff, 0xff8844, 0.3);
    scene.add(hemisphereLight);

    // ========================================
    // CREATE SCENE OBJECTS
    // ========================================

    const objects = [];

    // Create a grid of cubes to demonstrate perspective
    const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
    const spacing = 3;
    const gridSize = 3;

    for (let x = -gridSize; x <= gridSize; x++) {
      for (let z = -gridSize; z <= gridSize; z++) {
        const hue = (x + gridSize) / (gridSize * 2);
        const saturation = (z + gridSize) / (gridSize * 2);
        const color = new THREE.Color().setHSL(hue, saturation * 0.7 + 0.3, 0.5);

        const material = new THREE.MeshStandardMaterial({
          color: color,
          metalness: 0.3,
          roughness: 0.6
        });

        const cube = new THREE.Mesh(cubeGeo, material);
        cube.position.set(x * spacing, 0.5, z * spacing);
        cube.userData.originalY = 0.5; // Store original Y position
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);
        objects.push(cube);
      }
    }

    // Central focal point - taller cube
    const centralCubeGeo = new THREE.BoxGeometry(2, 4, 2);
    const centralMat = new THREE.MeshStandardMaterial({
      color: 0xff6b6b,
      metalness: 0.7,
      roughness: 0.2,
      emissive: 0xff2200,
      emissiveIntensity: 0.2
    });
    const centralCube = new THREE.Mesh(centralCubeGeo, centralMat);
    centralCube.position.set(0, 2, 0);
    centralCube.userData.originalY = 2; // Store original Y position
    centralCube.castShadow = true;
    centralCube.receiveShadow = true;
    scene.add(centralCube);
    objects.push(centralCube);

    // Create spheres at different distances to show perspective
    for (let i = 1; i <= 4; i++) {
      const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32);
      const sphereMat = new THREE.MeshStandardMaterial({
        color: 0x4ecdc4,
        metalness: 0.8,
        roughness: 0.1
      });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.position.set(i * 4, 1, i * 2);
      sphere.userData.originalY = 1; // Store original Y position
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      scene.add(sphere);
      objects.push(sphere);
    }

    // Ground plane
    const planeGeo = new THREE.PlaneGeometry(100, 100);
    const planeMat = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      metalness: 0.0,
      roughness: 0.9
    });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // Grid helper to visualize perspective
    const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
    scene.add(gridHelper);

    // Axes helper
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    // ========================================
    // CAMERA HELPER - Visualize camera frustum
    // ========================================

    let cameraHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
    // Uncomment to visualize light camera:
    // scene.add(cameraHelper);

    // ========================================
    // UI UPDATE FUNCTIONS
    // ========================================

    function updateCameraInfo() {
      document.getElementById('camera-name').textContent =
        cameraType === 'perspective' ? 'Perspective (Natural)' : 'Orthographic (Isometric)';

      if (cameraType === 'perspective') {
        document.getElementById('fov-value').textContent =
          Math.round(camera.fov) + '¬∞';
      } else {
        document.getElementById('fov-value').textContent = 'N/A (Ortho)';
      }

      const pos = camera.position;
      document.getElementById('camera-position').textContent =
        `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
    }

    // ========================================
    // CAMERA SWITCHING FUNCTIONS
    // ========================================

    function switchToPerspective() {
      const oldPosition = camera.position.clone();
      camera = perspectiveCamera;
      camera.position.copy(oldPosition);
      controls.object = camera;
      controls.target.set(0, 0, 0); // Reset orbit target to scene center
      controls.update(); // Apply changes immediately
      cameraType = 'perspective';
      updateCameraInfo();
      console.log('üì∏ Switched to Perspective Camera - Objects farther away appear smaller');
    }

    function switchToOrthographic() {
      const oldPosition = camera.position.clone();
      camera = orthographicCamera;
      camera.position.copy(oldPosition);
      controls.object = camera;
      controls.target.set(0, 0, 0); // Reset orbit target to scene center
      controls.update(); // Apply changes immediately
      cameraType = 'orthographic';
      updateCameraInfo();
      console.log('üì∏ Switched to Orthographic Camera - No perspective distortion (like CAD)');
    }

    function setFOV(fov) {
      if (cameraType === 'perspective') {
        camera.fov = fov;
        camera.updateProjectionMatrix();
        updateCameraInfo();
        console.log(`üéØ FOV set to ${fov}¬∞ - ${fov > 90 ? 'Wide angle' : fov < 50 ? 'Telephoto/Zoomed' : 'Normal'}`);
      }
    }

    function resetCamera() {
      camera.position.set(0, 5, 15);
      camera.lookAt(0, 0, 0);
      controls.target.set(0, 0, 0);
      if (cameraType === 'perspective') {
        camera.fov = 75;
        camera.updateProjectionMatrix();
      }
      updateCameraInfo();
      console.log('üîÑ Camera reset to default position');
    }

    // ========================================
    // KEYBOARD CONTROLS
    // ========================================

    const moveSpeed = 0.5;

    window.addEventListener('keydown', (event) => {
      switch (event.key) {
        case '1':
          switchToPerspective();
          break;
        case '2':
          switchToOrthographic();
          break;
        case '3':
          setFOV(100); // Wide angle
          break;
        case '4':
          setFOV(75); // Normal
          break;
        case '5':
          setFOV(35); // Narrow/Telephoto
          break;
        case 'r':
        case 'R':
          resetCamera();
          break;
        case 'ArrowUp':
          camera.position.y += moveSpeed;
          controls.update(); // Sync controls with new camera position
          updateCameraInfo();
          break;
        case 'ArrowDown':
          camera.position.y -= moveSpeed;
          controls.update(); // Sync controls with new camera position
          updateCameraInfo();
          break;
        case 'ArrowLeft':
          camera.position.x -= moveSpeed;
          controls.update(); // Sync controls with new camera position
          updateCameraInfo();
          break;
        case 'ArrowRight':
          camera.position.x += moveSpeed;
          controls.update(); // Sync controls with new camera position
          updateCameraInfo();
          break;
      }
    });

    // ========================================
    // ANIMATION LOOP
    // ========================================

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const elapsedTime = clock.getElapsedTime();

      // Rotate objects slowly
      objects.forEach((obj, index) => {
        obj.rotation.y = elapsedTime * 0.3 + index * 0.1;

        // Add subtle floating animation to some objects (oscillate around original Y)
        if (index % 2 === 0 && obj.userData.originalY !== undefined) {
          obj.position.y = obj.userData.originalY + Math.sin(elapsedTime * 2 + index) * 0.2;
        }
      });

      // Update controls
      controls.update();

      // Update camera info display (every frame for real-time feedback)
      updateCameraInfo();

      // Render
      renderer.render(scene, camera);
    }

    animate();

    // ========================================
    // WINDOW RESIZE HANDLER
    // ========================================

    window.addEventListener('resize', () => {
      const aspect = window.innerWidth / window.innerHeight;

      // Update perspective camera
      perspectiveCamera.aspect = aspect;
      perspectiveCamera.updateProjectionMatrix();

      // Update orthographic camera
      orthographicCamera.left = frustumSize * aspect / -2;
      orthographicCamera.right = frustumSize * aspect / 2;
      orthographicCamera.top = frustumSize / 2;
      orthographicCamera.bottom = frustumSize / -2;
      orthographicCamera.updateProjectionMatrix();

      // Update renderer
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    // ========================================
    // CONSOLE WELCOME
    // ========================================

    console.log('üì∏ Day 3: Camera & Controls Mastery!');
    console.log('');
    console.log('üìö What you\'re learning:');
    console.log('  ‚úì Perspective Camera - Natural view (farther = smaller)');
    console.log('  ‚úì Orthographic Camera - Parallel projection (no perspective)');
    console.log('  ‚úì Field of View (FOV) - How "wide" the camera sees');
    console.log('  ‚úì Camera positioning and lookAt');
    console.log('  ‚úì Advanced OrbitControls settings');
    console.log('');
    console.log('üéÆ Try these experiments:');
    console.log('  1. Press [1] and [2] to switch cameras - notice the difference!');
    console.log('  2. Press [3] [4] [5] to change FOV - see how it affects depth');
    console.log('  3. Use arrow keys to move camera manually');
    console.log('  4. Press [R] to reset camera');
    console.log('  5. Use mouse to orbit, pan, and zoom');
    console.log('');
    console.log('üí° Key Insight:');
    console.log('  Perspective camera mimics human vision.');
    console.log('  Orthographic camera is perfect for CAD, strategy games, UI.');

    // Initial UI update
    updateCameraInfo();
  </script>
</body>

</html>